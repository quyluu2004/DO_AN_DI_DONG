import 'dart:typed_data';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import '../models/feed_post_model.dart';
import '../models/comment_model.dart'; // [NEW]
import 'cloudinary_service.dart';

class FeedService {
  // Singleton
  static final FeedService instance = FeedService._internal();
  FeedService._internal();

  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  final FirebaseAuth _auth = FirebaseAuth.instance;

  // Collection Reference
  CollectionReference get _postsRef => _firestore.collection('feed_posts');

  /// Get real-time stream of feed posts
  Stream<List<FeedPost>> getFeedStream() {
    return _postsRef
        .orderBy('timestamp', descending: true)
        .snapshots()
        .map((snapshot) {
      return snapshot.docs.map((doc) {
        return FeedPost.fromMap(doc.data() as Map<String, dynamic>, doc.id);
      }).toList();
    });
  }

  /// Create a new post
  Future<void> createPost({
    required String description,
    required Uint8List imageBytes,
    required List<String> linkedProductIds,
  }) async {
    final user = _auth.currentUser;
    if (user == null) throw Exception('User must be logged in to post');

    // 1. Upload Image to Cloudinary
    final imageUrl = await CloudinaryService.instance.uploadImage(
      bytes: imageBytes,
      folder: 'feed_images',
    );

    // 2. Create Post Object
    // 2. Create Post Object
    String authorName = user.displayName ?? '';
    if (authorName.isEmpty) {
      authorName = user.email?.split('@')[0] ?? 'Fashion User';
    }

    final post = FeedPost(
      id: '', // ID will be generated by Firestore
      authorName: authorName,
      authorId: user.uid,
      authorAvatarUrl: user.photoURL ?? 'https://i.pravatar.cc/150?u=${user.uid}',
      imageUrl: imageUrl,
      description: description,
      likedBy: [],
      commentCount: 0,
      linkedProductIds: linkedProductIds,
      timestamp: DateTime.now(),
    );

    await _postsRef.add(post.toMap());
  }

  /// Toggle like status
  Future<void> toggleLike(String postId, String userId, List<String> currentLikedBy) async {
    final List<String> newLikedBy = List.from(currentLikedBy);
    if (newLikedBy.contains(userId)) {
      newLikedBy.remove(userId);
    } else {
      newLikedBy.add(userId);
    }
    await _postsRef.doc(postId).update({'likedBy': newLikedBy});
  }

  /// Get comments stream
  Stream<List<Comment>> getCommentsStream(String postId) {
    return _postsRef.doc(postId).collection('comments')
        .orderBy('timestamp', descending: false)
        .snapshots()
        .map((snapshot) => snapshot.docs.map((doc) => Comment.fromDoc(doc)).toList());
  }

  /// Add a comment
  Future<void> addComment(String postId, String content) async {
    final user = _auth.currentUser;
    if (user == null) throw Exception('Must be logged in');

    String authorName = user.displayName ?? '';
    if (authorName.isEmpty) {
      authorName = user.email?.split('@')[0] ?? 'Fashion User';
    }

    final comment = Comment(
      id: '',
      authorId: user.uid,
      authorName: authorName,
      authorAvatarUrl: user.photoURL ?? 'https://i.pravatar.cc/150?u=${user.uid}',
      content: content,
      timestamp: DateTime.now(),
    );

    // Batch write to update count atomically if possible, or simple separate writes
    // For simplicity:
    await _postsRef.doc(postId).collection('comments').add(comment.toMap());
    
    // Increment comment count
    await _postsRef.doc(postId).update({
      'commentCount': FieldValue.increment(1)
    });
  }

  // ... inside FeedService

  /// Get real-time stream of posts by a specific user
  Stream<List<FeedPost>> getUserPostsStream(String userId) {
    return _postsRef
        .where('authorId', isEqualTo: userId)
        .orderBy('timestamp', descending: true)
        .snapshots()
        .map((snapshot) {
      return snapshot.docs.map((doc) {
        return FeedPost.fromMap(doc.data() as Map<String, dynamic>, doc.id);
      }).toList();
    });
  }

  /// Delete a post
  Future<void> deletePost(String postId) async {
    await _postsRef.doc(postId).delete();
  }

  // Fallback for Future-based calls if needed, but Stream is preferred
  Future<List<FeedPost>> getFeedPosts() async {
    final snapshot = await _postsRef.orderBy('timestamp', descending: true).get();
    return snapshot.docs.map((doc) {
      return FeedPost.fromMap(doc.data() as Map<String, dynamic>, doc.id);
    }).toList();
  }
}
